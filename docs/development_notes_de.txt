Projektziel
- Entwicklung eines stromsparenden Fahrrad-Computers auf ESP32-Basis mit Telemetrie, Anzeige und Diebstahlschutz.

Überblick
- Vereinfachte Zustandsmaschine (INIT, IDLE, ACTIVE, DISCONNECTED) für klare Ablaufsteuerung.
- CoAP-Server-Architektur: ESP32 hostet Ressourcen, Android-App pollt Telemetriedaten.
- 16x2 I2C-LCD zur Anzeige von Uhrzeit, Umwelt- und Bewegungsdaten; einfache UI-Pages per Button.
- Energieoptimierung durch adaptive Sensor-Abtastrate und Loop-Verzögerungen.

Hardware
- ESP32 DevKit (Arduino-Framework).
- Sensoren: DHT22 (Temperatur/Luftfeuchte), MPU6050 (Beschleunigung/Gyro).
- Uhr: DS1302 RTC (Zeit für Anzeige/Logs; Set auf Build-Zeit beim Flashen).
- Anzeige: 16x2 I2C LCD (`LiquidCrystal_I2C`).
- LED: RGB-LED für Statusmeldungen (Rot/Blau/Grün, SOS-Pattern bei Diebstahl).
- Button: Seitenwechsel und Backlight-Aktivierung; konfigurierbar per `Config::BUTTON_PULLUP` (true=Pull-up, false=Pull-down).
  - Erste Taste nach LCD-Timeout: Nur Backlight aktivieren, keine Seitenwechsel.
  - Nachfolgende Tasten: Normale Seitenwechsel-Funktion.

Software & Bibliotheken
- PlatformIO-Projekt mit Arduino-Core.
- Bibliotheken: DHT_Unified, Adafruit_MPU6050, LiquidCrystal_I2C, RtcDS1302, CoAP-simple, WiFi/WiFiUDP.
- Projektstruktur: `src/` (Logik), `lib/` (ggf. Zusatz), `docs/` (Dokumentation), `test/` (Platzhalter).

Zustände & Logik
- INIT: Hardware-Init, erste Sensorchecks, WLAN-Start, CoAP-Server-Initialisierung.
- IDLE: Verbunden, keine Bewegung; Sensorfrequenz 1 Hz (1s Intervall); Server bereit für Anfragen.
- ACTIVE: Verbunden, Bewegung erkannt; Sensorfrequenz 5 Hz (200ms Intervall); Server bereit für Anfragen.
- DISCONNECTED: WLAN verloren; Reconnect-Versuch alle 10 Minuten; Display bleibt funktional.

Sensorik
- DHT22: Gelesen mit `Config::DHT_READ_MS`-Throttling (2000ms); Initialcheck im Setup (OK/FAILED).
  - Fallback-Werte bei Ausfall: 20.0°C Temperatur, 50% Luftfeuchtigkeit.
- MPU6050: Bewegungsdetektion über Magnituden von Beschleunigung und Gyro; Schwellwerte konfigurierbar.
  - Achsen-Mapping: Z→X, Y→Y, X→Z (für korrekte Orientierung am Fahrrad).
  - Fallback-Werte bei Ausfall: ax=0.0, ay=0.0, az=9.81, gx/gy/gz=0.0.
- Bewegung: `MOVEMENT_ACCEL_THRESHOLD` (1.0 m/s²), `MOVEMENT_GYRO_THRESHOLD` (5.0 rad/s); Timeout `MOVEMENT_TIMEOUT_MS` (10s).
- Diebstahlschutz: Verwendet gleiche Bewegungserkennung wie normale Bewegung; nur aktiv wenn `state.locked == true`.
  - LOCK-Befehl aktiviert Überwachung, UNLOCK deaktiviert und setzt Alarm zurück.
  - Bei Bewegung im gesperrten Zustand: `theft_detected = true` → LED-SOS-Pattern.

Kommunikation (CoAP-Server)
- ESP32 agiert als CoAP-Server auf Port 5683.
- Ressourcen:
	- /telemetry (GET): Liefert aktuelle Sensordaten als JSON.
	- /cmd (POST): Empfängt Befehle (z.B. "LOCK", "UNLOCK").
- Android-App pollt Daten nach Bedarf (empfohlen: 1-2s Intervall).
- CoAP-Loop läuft mit 100ms Intervall für responsive Serverantworten.
- Re-Init von CoAP-Server nach WLAN-Reconnect.

Energie & Power-Management
- WiFi-Light-Sleep ist **deaktiviert** (`disableWiFiSleep()`) für zuverlässige CoAP-Server-Verfügbarkeit.
- Adaptive Loop-Verzögerungen: Active=20ms, Idle=100ms, Disconnected=1000ms.
- Adaptive Sensor-Abtastrate: Active=200ms (5Hz), Idle=1000ms (1Hz).
- Kein Deep-Sleep im Server-Modus (für permanente Verfügbarkeit).

Anzeige & LED
- LCD-Pages:
	- Zeit/Datum (RTC).
	- Umwelt (Temperatur, Luftfeuchte + DHT-Status).
	- Bewegung (Accel/Gyro live).
	- Netzwerk/State (WiFi-Status, lokale IP).
- LCD-Hintergrundbeleuchtung:
	- Automatisches Timeout nach 30 Sekunden Inaktivität.
	- Reaktivierung durch Tastendruck.
	- Sofortige Aktivierung bei Benutzereingabe für direktes Feedback.
- LED-Status (Priorität absteigend):
	- THEFT_ALERT: Rot-SOS (3 kurz, 3 lang, 3 kurz) - höchste Priorität, nur wenn gesperrt und Diebstahl erkannt.
	- COAP_ERROR: Rot - wenn WiFi verbunden aber keine CoAP-Aktivität seit >30s.
	- INIT: Blau-Blink - während Initialisierung oder WiFi-Verbindung.
	- SYSTEM_OK: Grün - normaler Betrieb, alle Systeme funktional.
	- COAP_CONNECTING: Blau (veraltet, nicht mehr aktiv verwendet).

Netzwerkdiagnostik
- WLAN-Scan vor Verbindungsaufbau; klare Statuslogs (z. B. `WL_NO_SSID_AVAIL`).
- Auto-Reconnect: Beim Boot deaktiviert für kontrollierte Verbindungsversuche; nach erfolgreicher Verbindung automatisch aktiviert.
- Manuelle Reconnect-Versuche: alle 60 Sekunden wenn nicht verbunden.
- UDP-Socket wird bei Disconnect sofort gestoppt und bei Reconnect vollständig neu initialisiert.
- CoAP-Server erst nach erfolgreichem WLAN-Connect gestartet.

Build & Deployment
- PlatformIO: Build, Upload, serielle Logs für Diagnose.
- RTC wird beim Flashen auf Build-Zeit gesetzt (aus `__DATE__`/`__TIME__`).

Fehlerbehebung (Troubleshooting)
- WLAN verbindet nicht: SSID im 2,4 GHz-Band, nicht verborgen; Gerät näher am AP; SSID exakt prüfen.
- DHT unzuverlässig: Stabilisierung (200 ms), Lese-Intervall erhöhen, Verkabelung/5V/3,3V und Pullup prüfen.
- Button reagiert nicht: Pull-up/-down-Config beachten, Rohwerte loggen, Verdrahtung kontrollieren.
- UDP-Fehler-Spam: CoAP-Loop nur bei WLAN-Verbindung ausführen.

Roadmap
- Exponentielles Backoff für WiFi-Reconnect (aktuell fest 60s).
- Filterung/Glättung von Bewegungsdaten für stabilere Erkennung.
- Batteriespannungsüberwachung und Warnung bei niedrigem Ladestand.

Hinweise
- APIs: Optional geplante Nutzung externer Wetter-/Zeit-Dienste; aktuell lokal über RTC.
- Zielkriterium: stabiles, energieeffizientes Laufverhalten (>1 h) mit verlässlicher Anzeige/Telemetrie.

Systemarchitektur des ESP32 Fahrrad-Computers
Einleitung und Systemüberblick
Der ESP32 Fahrrad-Computer ist ein autonomes Edge-Computing-System, das speziell für den Einsatz an Fahrrädern entwickelt wurde. Es fungiert als intelligentes IoT-Gerät, das Umgebungsdaten und Bewegungsaktivitäten in Echtzeit erfasst, lokal verarbeitet und über drahtlose Kommunikationstechnologien an einen zentralen Server übermittelt. Das System ist darauf ausgelegt, sowohl als klassischer Fahrradcomputer mit Displayanzeige als auch als Telemetrie-Einheit mit Diebstahlschutzfunktion zu arbeiten.

Hardware-Architektur
Das Herzstück des Systems bildet ein ESP32 DevKit mit einem Dual-Core Xtensa LX6 Prozessor, der mit 240 MHz getaktet ist. Dieser Mikrocontroller übernimmt die zentrale Steuerung aller Peripheriegeräte und die Ausführung der Anwendungslogik. Dank seiner integrierten WiFi-Funktionalität und diversen Low-Power-Modi eignet er sich ideal für batteriebetriebene IoT-Anwendungen.

Die Sensorik des Systems setzt sich aus zwei Hauptkomponenten zusammen. Für die Erfassung von Umweltdaten wird ein DHT22-Sensor verwendet, der Temperatur und relative Luftfeuchtigkeit misst. Zur Bewegungserkennung kommt ein MPU6050 zum Einsatz, ein MEMS-Sensor, der sowohl einen 3-Achsen-Beschleunigungssensor als auch ein 3-Achsen-Gyroskop vereint. Diese Kombination ermöglicht eine präzise Detektion von Fahrzuständen sowie Erschütterungen, die auf einen Diebstahlversuch hindeuten könnten.

Um eine kontinuierliche und präzise Zeitmessung unabhängig von einer Netzwerkverbindung zu gewährleisten, ist das System mit einer DS1302 Echtzeituhr (RTC) ausgestattet. Diese verfügt über eine eigene Batterie-Pufferung und wird beim Flashen der Firmware automatisch mit der Build-Zeit synchronisiert.

Die Interaktion mit dem Benutzer erfolgt über ein 16x2 LCD-Display, das über einen I2C-Bus angesteuert wird. Es visualisiert auf vier umschaltbaren Seiten Informationen wie Uhrzeit, Datum, aktuelle Sensorwerte sowie den Netzwerkstatus. Ergänzt wird die Anzeige durch eine RGB-LED, die den Systemstatus farblich kodiert: Blau signalisiert den Initialisierungs- oder Verbindungsstatus, Grün steht für den regulären Betrieb, und Rot warnt vor Fehlern oder einem aktiven Diebstahlalarm. Ein einfacher Drucktaster ermöglicht dem Nutzer das Durchschalten der verschiedenen Displayseiten.

Software-Architektur und Zustandssteuerung
Die Software basiert auf dem Arduino-Framework und wird mittels PlatformIO entwickelt. Die Anwendungslogik ist als vereinfachte Finite State Machine implementiert, was ein deterministisches und robustes Verhalten gewährleistet. Das System durchläuft dabei vier definierte Zustände:

Nach dem Start befindet sich das System im INIT-Zustand, in dem die Hardware initialisiert, die Sensoren auf Funktionsfähigkeit geprüft werden und der CoAP-Server gestartet wird. Bei erfolgreicher WLAN-Verbindung wechselt es direkt in den IDLE-Zustand.

Im regulären Betrieb unterscheidet das System zwischen zwei Hauptzuständen: IDLE und ACTIVE. Der IDLE-Zustand wird eingenommen, wenn das Fahrrad steht. Hierbei arbeitet das System energiesparend mit reduzierter Sensor-Abtastrate von 1 Hz. Sobald der MPU6050-Sensor eine Bewegung registriert, die definierte Schwellwerte überschreitet, wechselt das System in den ACTIVE-Zustand. In diesem Modus werden die Sensoren mit 5 Hz ausgelesen, um präzise Bewegungsdaten bereitzustellen.

Sollte die Netzwerkverbindung abreißen, geht das System in den DISCONNECTED-Zustand über, in dem es alle 10 Minuten versucht, die Verbindung wiederherzustellen, ohne dabei die lokale Funktionalität (wie die Displayanzeige) zu beeinträchtigen. Der CoAP-Server bleibt verfügbar, sobald die Verbindung wiederhergestellt ist.

Kommunikation und Datenprotokoll
Für die Datenübertragung nutzt das System das CoAP-Protokoll (Constrained Application Protocol) über UDP, was aufgrund seines geringen Overheads ideal für IoT-Anwendungen ist. Das Gerät agiert als CoAP-Server und hostet Ressourcen, die von einer Android-App abgefragt werden können.

Die Nutzdaten werden als kompakte JSON-Objekte formatiert. Unabhängig vom Zustand (IDLE oder ACTIVE) enthält das Datenpaket immer vollständige Informationen: Temperatur, Luftfeuchtigkeit sowie die Rohdaten der Beschleunigungs- und Gyroskopsensoren aller drei Achsen. Ein Statusfeld ("s") kennzeichnet den aktuellen Zustand: "A" für Active (Bewegung) oder "I" für Idle (Ruhe).

Energie-Management
Ein wesentlicher Aspekt der Architektur ist das Energie-Management. Das System nutzt adaptive Verzögerungen in der Hauptschleife (Loop), die je nach Systemzustand variieren: 20ms im ACTIVE-Zustand für schnelle Reaktion, 100ms im IDLE-Zustand für Energieeinsparung, und 1000ms im DISCONNECTED-Zustand zur Minimierung des Verbrauchs während Verbindungsversuchen. Das WiFi-Modul bleibt permanent aktiv (Light-Sleep deaktiviert), um als zuverlässiger CoAP-Server zu fungieren. Deep-Sleep ist bewusst nicht implementiert, da das System kontinuierlich für Abfragen der Android-App verfügbar sein muss.
Zusammenfassend stellt der ESP32 Fahrrad-Computer eine integrierte Lösung dar, die lokale Echtzeitverarbeitung mit effizienter Netzwerk-Konnektivität verbindet und durch ihre modulare Architektur flexibel auf verschiedene Einsatzszenarien angepasst werden kann.

### Detaillierte Beschreibung der CoAP-Schnittstelle

Das Gerät agiert als **CoAP-Server** und hostet Ressourcen, die von einer Android-App abgerufen werden.

*   **Protokoll:** CoAP (Constrained Application Protocol) über UDP.
*   **Port:** `5683` (Standard CoAP-Port)
*   **Architektur:** ESP32 als Server, Android-App als Client

#### Verfügbare Ressourcen:

**1. `/telemetry` (GET)**
*   **Zweck:** Abruf aktueller Sensordaten
*   **Methode:** `GET`
*   **Response:** CoAP ACK mit JSON-Payload
*   **Content-Type:** `application/json`
*   **Polling-Empfehlung:** 1-2 Sekunden für Echtzeit-Updates
*   **Payload-Struktur:**
    ```json
    {
      "t": 24.5,       // Temperatur (Celsius)
      "h": 55.2,       // Luftfeuchtigkeit (%)
      "ax": 0.12,      // Beschleunigung X (m/s²)
      "ay": -0.05,     // Beschleunigung Y (m/s²)
      "az": 0.98,      // Beschleunigung Z (m/s²)
      "gx": 0.01,      // Gyro X (rad/s)
      "gy": 0.02,      // Gyro Y (rad/s)
      "gz": -0.01,     // Gyro Z (rad/s)
      "theft": "N",   // Diebstahlstatus: "Y" = erkannt, "N" = nicht erkannt
      "s": "A"         // Status: "A" für Active, "I" für Idle
    }
    ```

**2. `/cmd` (POST)**
*   **Zweck:** Senden von Befehlen an das Gerät
*   **Methode:** `POST`
*   **Payload:** Text (z.B. "LOCK", "UNLOCK")
*   **Response:** "OK" bei Erfolg
*   **Verwendung:** 
    - **LOCK**: Aktiviert Diebstahlüberwachung (`state.locked = true`). Bei Überschreitung der Theft-Schwellwerte → `theft_detected = true` → LED-SOS-Muster.
    - **UNLOCK**: Deaktiviert Überwachung (`state.locked = false`) und setzt Diebstahlalarm zurück (`theft_detected = false`).

#### Android-Client-Implementierung:
Projektdokumentation: CycleComputer
Version: 1.0 Datum: 11. Dezember 2025
1. Projektübersicht
Das Projekt "CycleComputer" ist eine native Android-Anwendung, die als Fahrradcomputer fungiert. Die App verbindet sich mit einem externen IoT-Gerät (vermutlich einem Mikrocontroller wie einem ESP32 oder Arduino) über das CoAP-Protokoll, um Echtzeit-Telemetriedaten zu empfangen und zu visualisieren. Zusätzlich kann der Benutzer Befehle an das Gerät senden, wie z.B. das Ver- oder Entriegeln eines Schlosses. Die App integriert auch Standortdienste, um die aktuelle Geschwindigkeit des Fahrrads zu schätzen und Wetterdaten für den aktuellen Standort abzurufen.
2. Technische Architektur
Die Anwendung basiert auf einer Single-Activity-Architektur (DataActivity.java) und nutzt moderne Android-Komponenten und Bibliotheken.
•
Kommunikationsprotokoll: Die Kommunikation mit dem externen Gerät erfolgt über CoAP (Constrained Application Protocol), ein leichtgewichtiges Protokoll, das ideal für IoT-Anwendungen ist. Die Implementierung wird durch die californium-core-Bibliothek realisiert.
•
Datenverarbeitung: Eingehende Daten vom IoT-Gerät liegen im JSON-Format vor. Die Gson-Bibliothek wird für das Parsen dieser Daten in Java-Objekte (TelemetryData) verwendet.
•
UI-Aktualisierung & State Management: Android Architecture Components, insbesondere LiveData und Observer, werden verwendet, um die Benutzeroberfläche reaktiv zu gestalten. Der CoapManager stellt LiveData-Objekte für Telemetriedaten und den Verbindungsstatus bereit, welche die DataActivity beobachtet und bei Änderungen die UI aktualisiert.
•
Standort und Geschwindigkeit: Der FusedLocationProviderClient von den Google Play Services wird genutzt, um den Gerätestandort zu ermitteln. Die Geschwindigkeit wird nicht direkt über GPS, sondern durch die Integration von Beschleunigungssensordaten berechnet. Ein Hochpassfilter trennt die lineare Beschleunigung von der Schwerkraft, um eine realistische Geschwindigkeitsabschätzung zu ermöglichen.
•
Netzwerkanfragen (Wetter): Für das Abrufen von Wetterdaten von einer externen API (weatherapi.com) wird die Fuel-Bibliothek eingesetzt. Dies ist eine leichtgewichtige und benutzerfreundliche HTTP-Client-Bibliothek für Kotlin/Java.
3. Kernkomponenten
a) DataActivity.java Dies ist die Haupt- und einzige Activity der App. Sie ist verantwortlich für:
•
Anzeige von Daten: Visualisierung von Temperatur, Luftfeuchtigkeit, Beschleunigung, Gyroskopwerten, Geschwindigkeit und Gerätestatus.
•
Benutzerinteraktionen: Verarbeitung von Klicks auf Buttons (z.B. "Sperren senden", "Rohdaten anzeigen").
•
Lifecycle-Management: Initialisierung und Freigabe von Ressourcen wie dem CoapManager und den Observern.
•
Berechtigungsmanagement: Anforderung der ACCESS_FINE_LOCATION-Berechtigung, die für den Abruf von Wetterdaten benötigt wird.
b) CoapManager.java (Singleton) Diese zentrale Klasse kapselt die gesamte CoAP-Kommunikationslogik.
•
Verbindungsmanagement: Stellt eine "observe"-Beziehung zu einer Ressource auf dem CoAP-Server (dem IoT-Gerät) her.
•
Datenbereitstellung: Empfängt Daten vom Server und stellt sie über ein MutableLiveData<String>-Objekt bereit.
•
Status-Management: Verfolgt den Verbindungsstatus (IDLE, ACTIVE, DISCONNECTED) und stellt diesen ebenfalls über LiveData zur Verfügung.
•
Befehle senden: Bietet eine Methode (sendCommand), um PUT-Anfragen (z.B. "LOCK" / "UNLOCK") an den CoAP-Server zu senden.
c) TelemetryData.java (Datenklasse) Eine einfache Datenklasse, die die Struktur der vom IoT-Gerät gesendeten JSON-Daten widerspiegelt. Sie enthält Felder für Temperatur, Luftfeuchtigkeit, Beschleunigungs- und Gyroskopwerte sowie einen Status.
d) WeatherApiResponse.java (Datenklasse) Eine verschachtelte Datenklasse, die für das Parsen der JSON-Antwort der Wetter-API mit Gson verwendet wird.
4. Abhängigkeiten (Dependencies)
•
androidx.appcompat: Für grundlegende UI-Komponenten und Abwärtskompatibilität.
•
com.google.android.material: Für moderne Material-Design-Komponenten wie SwitchCompat.
•
org.eclipse.californium:californium-core: Implementierung des CoAP-Protokolls.
•
com.google.code.gson:gson: Zum Parsen von JSON-Daten.
•
com.github.kittinunf.fuel:fuel: Für HTTP-Anfragen (Wetter-API).
•
com.google.android.gms:play-services-location: Für den Zugriff auf den Gerätestandort.
App-Dokumentation (Benutzerhandbuch)
1. Einleitung
Willkommen bei der CycleComputer App! Diese App verwandelt Ihr Smartphone in eine leistungsstarke Zentrale für Ihr Fahrrad. Verbinden Sie sich mit Ihrem smarten Fahrrad-Zubehör, um Live-Daten wie Temperatur und Geschwindigkeit zu sehen, und steuern Sie Funktionen wie das digitale Schloss direkt von Ihrem Handy aus.
2. Hauptbildschirm (DataActivity)
Der Hauptbildschirm ist das Herzstück der App und bietet Ihnen alle wichtigen Informationen auf einen Blick. Die Hintergrundfarbe des Bildschirms signalisiert den aktuellen Verbindungsstatus:
•
Grau (status_idle): Die App ist bereit, hat aber noch keine aktiven Daten vom Gerät empfangen.
•
Grün (status_active): Eine aktive Verbindung zum Gerät besteht und Daten werden empfangen.
•
Rot (status_disconnected): Die Verbindung zum Gerät wurde unterbrochen.
3. Angezeigte Daten
•
Gerätestatus: Zeigt den aktuellen Status des verbundenen Geräts an (z.B. "ACTIVE" oder "IDLE").
•
Geschwindigkeit: Ihre aktuelle Fahrgeschwindigkeit, berechnet in Kilometern pro Stunde (km/h).
•
Wetter: Das aktuelle Wetter an Ihrem Standort (z.B. "Sonnig", "Leichter Regen"). Hierfür ist eine Standortfreigabe erforderlich.
•
Temperatur: Die vom Sensor gemessene Umgebungstemperatur in Grad Celsius (°C).
•
Luftfeuchtigkeit: Die vom Sensor gemessene relative Luftfeuchtigkeit in Prozent (%).
4. Steuerelemente
•
Sperren / Entsperren (Schalter):
◦
Mit dem Schalter können Sie den Zustand eines digitalen Schlosses an Ihrem Fahrrad steuern.
◦
Position "An" (aktiviert): Das Schloss ist verriegelt.
◦
Position "Aus" (deaktiviert): Das Schloss ist entriegelt.
•
Befehl senden (Button):
◦
Nachdem Sie den Zustand des Schalters geändert haben, tippen Sie auf diesen Button, um den Befehl ("LOCK" oder "UNLOCK") an Ihr Fahrrad zu senden.
•
Rohdaten anzeigen/verbergen (Button):
◦
Für technisch interessierte Benutzer. Ein Tipp auf diesen Button blendet die detaillierten Rohdaten der Sensoren ein oder aus:
▪
Beschleunigung (Accel): Die Messwerte der X-, Y- und Z-Achse des Beschleunigungssensors.
▪
Gyroskop (Gyro): Die Messwerte der X-, Y- und Z-Achse des Gyroskops.
5. Erstmalige Einrichtung und Berechtigungen
Beim ersten Start der App werden Sie aufgefordert, die Berechtigung für den Standortzugriff (ACCESS_FINE_LOCATION) zu erteilen. Diese Berechtigung wird ausschließlich benötigt, um die aktuellen Wetterdaten für Ihren Standort abzurufen. Wenn Sie die Berechtigung nicht erteilen, wird anstelle des Wetters "N/A" (nicht verfügbar) angezeigt.
6. Fehlerbehandlung
•
"Fehler: Ungültige JSON-Daten": Diese Meldung erscheint, wenn die App Daten vom Gerät in einem unerwarteten Format empfängt. Stellen Sie sicher, dass die Firmware Ihres IoT-Geräts korrekt funktioniert.
•
Wetter "N/A": Dies kann auftreten, wenn Sie die Standortberechtigung verweigert haben, Ihr Gerät keine Standortinformationen liefern kann oder keine Internetverbindung besteht.
•
Roter Hintergrund: Wenn der Bildschirm rot wird, ist die Verbindung zum Fahrrad-Zubehör unterbrochen. Überprüfen Sie, ob das Gerät eingeschaltet und in Reichweite ist.