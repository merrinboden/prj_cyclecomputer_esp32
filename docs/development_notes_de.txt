Projektziel
- Entwicklung eines stromsparenden Fahrrad-Computers auf ESP32-Basis mit Telemetrie, Anzeige und Diebstahlschutz.

Überblick
- Vereinfachte Zustandsmaschine (INIT, IDLE, ACTIVE, DISCONNECTED) für klare Ablaufsteuerung.
- CoAP-Server-Architektur: ESP32 hostet Ressourcen, Android-App pollt Telemetriedaten.
- 16x2 I2C-LCD zur Anzeige von Uhrzeit, Umwelt- und Bewegungsdaten; einfache UI-Pages per Button.
- Energieoptimierung durch adaptive Sensor-Abtastrate und Loop-Verzögerungen.

Hardware
- ESP32 DevKit (Arduino-Framework).
- Sensoren: DHT22 (Temperatur/Luftfeuchte), MPU6050 (Beschleunigung/Gyro).
- Uhr: DS1302 RTC (Zeit für Anzeige/Logs; Set auf Build-Zeit beim Flashen).
- Anzeige: 16x2 I2C LCD (`LiquidCrystal_I2C`).
- LED: RGB-LED für Statusmeldungen (Rot/Blau/Grün, SOS-Pattern bei Diebstahl).
- Button: Seitenwechsel und Backlight-Aktivierung; konfigurierbar per `Config::BUTTON_PULLUP` (true=Pull-up, false=Pull-down).
  - Erste Taste nach LCD-Timeout: Nur Backlight aktivieren, keine Seitenwechsel.
  - Nachfolgende Tasten: Normale Seitenwechsel-Funktion.

Software & Bibliotheken
- PlatformIO-Projekt mit Arduino-Core.
- Bibliotheken: DHT_Unified, Adafruit_MPU6050, LiquidCrystal_I2C, RtcDS1302, CoAP-simple, WiFi/WiFiUDP.
- Projektstruktur: `src/` (Logik), `lib/` (ggf. Zusatz), `docs/` (Dokumentation), `test/` (Platzhalter).

Zustände & Logik
- INIT: Hardware-Init, erste Sensorchecks, WLAN-Start, CoAP-Server-Initialisierung.
- IDLE: Verbunden, keine Bewegung; Sensorfrequenz 1 Hz (1s Intervall); Server bereit für Anfragen.
- ACTIVE: Verbunden, Bewegung erkannt; Sensorfrequenz 5 Hz (200ms Intervall); Server bereit für Anfragen.
- DISCONNECTED: WLAN verloren; Reconnect-Versuch alle 10 Minuten; Display bleibt funktional.

Sensorik
- DHT22: Gelesen mit `Config::DHT_READ_MS`-Throttling (2000ms); Initialcheck im Setup (OK/FAILED).
  - Fallback-Werte bei Ausfall: 20.0°C Temperatur, 50% Luftfeuchtigkeit.
- MPU6050: Bewegungsdetektion über Magnituden von Beschleunigung und Gyro; Schwellwerte konfigurierbar.
  - Achsen-Mapping: Z→X, Y→Y, X→Z (für korrekte Orientierung am Fahrrad).
  - Fallback-Werte bei Ausfall: ax=0.0, ay=0.0, az=9.81, gx/gy/gz=0.0.
- Bewegung: `MOVEMENT_ACCEL_THRESHOLD` (1.0 m/s²), `MOVEMENT_GYRO_THRESHOLD` (5.0 rad/s); Timeout `MOVEMENT_TIMEOUT_MS` (10s).
- Diebstahlschutz: Verwendet gleiche Bewegungserkennung wie normale Bewegung; nur aktiv wenn `state.locked == true`.
  - LOCK-Befehl aktiviert Überwachung, UNLOCK deaktiviert und setzt Alarm zurück.
  - Bei Bewegung im gesperrten Zustand: `theft_detected = true` → LED-SOS-Pattern.

Kommunikation (CoAP-Server)
- ESP32 agiert als CoAP-Server auf Port 5683.
- Ressourcen:
	- /telemetry (GET): Liefert aktuelle Sensordaten als JSON.
	- /cmd (POST): Empfängt Befehle (z.B. "LOCK", "UNLOCK").
- Android-App pollt Daten nach Bedarf (empfohlen: 1-2s Intervall).
- CoAP-Loop läuft mit 100ms Intervall für responsive Serverantworten.
- Re-Init von CoAP-Server nach WLAN-Reconnect.

Energie & Power-Management
- WiFi-Light-Sleep ist **deaktiviert** (`disableWiFiSleep()`) für zuverlässige CoAP-Server-Verfügbarkeit.
- Adaptive Loop-Verzögerungen: Active=20ms, Idle=100ms, Disconnected=1000ms.
- Adaptive Sensor-Abtastrate: Active=200ms (5Hz), Idle=1000ms (1Hz).
- Kein Deep-Sleep im Server-Modus (für permanente Verfügbarkeit).

Stromverbrauch & Batterielaufzeit-Schätzungen

Komponentenverbrauch (typische Werte):
- ESP32 (240 MHz, WiFi aktiv, kein Sleep): ~160-240 mA
- ESP32 (240 MHz, WiFi aktiv, Light Sleep): ~20-30 mA (nicht verwendet)
- WiFi TX/RX Spitzen: bis 400 mA kurzzeitig
- LCD mit Backlight: ~20-30 mA
- LCD ohne Backlight: ~5 mA
- DHT22: ~1.5 mA (während Messung), <0.1 mA (Standby)
- MPU6050: ~3.5 mA (aktiv), ~8 µA (Sleep, nicht verwendet)
- DS1302 RTC: ~300 µA
- RGB LED (eine Farbe): ~5-20 mA (je nach Helligkeit)

Durchschnittlicher Verbrauch nach Zustand:
1. IDLE (WiFi verbunden, LCD Backlight aus, Sensoren 1 Hz):
   - ESP32 + WiFi: ~180 mA
   - LCD (kein Backlight): 5 mA
   - Sensoren (periodisch): ~2 mA gemittelt
   - LED (grün): ~10 mA
   - RTC: 0.3 mA
   - Total: ~197 mA

2. ACTIVE (WiFi verbunden, LCD Backlight an, Sensoren 5 Hz):
   - ESP32 + WiFi: ~200 mA (höhere Aktivität)
   - LCD (mit Backlight): 25 mA
   - Sensoren (häufiger): ~4 mA gemittelt
   - LED (grün): ~10 mA
   - RTC: 0.3 mA
   - Total: ~239 mA

3. DISCONNECTED (WiFi Reconnect-Versuche, LCD Backlight aus):
   - ESP32 + WiFi: ~150 mA (reduziert durch längere Delays)
   - LCD (kein Backlight): 5 mA
   - Sensoren: ~2 mA
   - LED (blau blinkend): ~8 mA gemittelt
   - RTC: 0.3 mA
   - Total: ~165 mA

4. THEFT_ALERT (gesperrt, Bewegung erkannt):
   - Basis wie IDLE: ~197 mA
   - LED (rot SOS-Pattern): ~15 mA gemittelt
   - Total: ~212 mA

Batterielaufzeit-Szenarien:

Szenario A - Normale Fahrt (typisch):
- 10% INIT/DISCONNECTED (165 mA)
- 30% IDLE mit Backlight aus (197 mA)
- 50% ACTIVE mit Backlight an (239 mA)
- 10% IDLE mit Backlight an (222 mA)
- Durchschnitt: ~220 mA

Szenario B - Langzeitüberwachung (geparkt):
- 90% IDLE ohne Backlight (197 mA)
- 10% gelegentliche Aktivität (239 mA)
- Durchschnitt: ~181 mA

Szenario C - Diebstahlalarm aktiv:
- 100% THEFT_ALERT (212 mA)
- Durchschnitt: 212 mA

Geschätzte Batterielaufzeit bei verschiedenen Kapazitäten:

1. 1000 mAh Akku (z.B. kleine LiPo):
   - Szenario A (Fahrt): 1000 / 220 ≈ 4,5 Stunden
   - Szenario B (Überwachung): 1000 / 181 ≈ 5,5 Stunden
   - Szenario C (Alarm): 1000 / 212 ≈ 4,7 Stunden

2. 2500 mAh Akku (z.B. 18650 Li-Ion):
   - Szenario A (Fahrt): 2500 / 220 ≈ 11,4 Stunden
   - Szenario B (Überwachung): 2500 / 181 ≈ 13,8 Stunden
   - Szenario C (Alarm): 2500 / 212 ≈ 11,8 Stunden

3. 5000 mAh Akku (z.B. USB Power Bank):
   - Szenario A (Fahrt): 5000 / 220 ≈ 22,7 Stunden
   - Szenario B (Überwachung): 5000 / 181 ≈ 27,6 Stunden
   - Szenario C (Alarm): 5000 / 212 ≈ 23,6 Stunden

10000 mAh Akku (große Power Bank):
   - Szenario A (Fahrt): 10000 / 220 ≈ 45,5 Stunden
   - Szenario B (Überwachung): 10000 / 181 ≈ 55,2 Stunden
   - Szenario C (Alarm): 10000 / 212 ≈ 47,2 Stunden

Hinweise zu Batterielaufzeit:
- Reale Laufzeit liegt ca. 80-85% der berechneten Werte (Batterie-Effizienz, Spannungswandler-Verluste).
- CoAP-Polling-Frequenz der Android-App beeinflusst WiFi-Aktivität und Verbrauch.
- Umgebungstemperatur beeinflusst Batteriekapazität (Kälte reduziert verfügbare Kapazität).
- WiFi-Signalstärke beeinflusst Sendeleistung (schlechtes Signal = höherer Verbrauch).
- LCD-Backlight-Nutzung hat signifikanten Einfluss (~25 mA Unterschied).

Optimierungsempfehlungen:
- LCD-Backlight möglichst kurz nutzen (30s Timeout ist sinnvoll).
- Bei Nichtnutzung: System in DISCONNECTED-Modus versetzen (WiFi aus).
- Für längere Überwachung: Externe Stromversorgung (USB) empfohlen.
- Zukünftig: WiFi-Light-Sleep implementieren für Überwachungsmodus (kann Verbrauch auf ~50-80 mA senken).

Anzeige & LED
- LCD-Pages:
	- Zeit/Datum (RTC).
	- Umwelt (Temperatur, Luftfeuchte + DHT-Status).
	- Bewegung (Accel/Gyro live).
	- Netzwerk/State (WiFi-Status, lokale IP).
- LCD-Hintergrundbeleuchtung:
	- Automatisches Timeout nach 30 Sekunden Inaktivität.
	- Reaktivierung durch Tastendruck.
	- Sofortige Aktivierung bei Benutzereingabe für direktes Feedback.
- LED-Status (Priorität absteigend):
	- THEFT_ALERT: Rot-SOS (3 kurz, 3 lang, 3 kurz) - höchste Priorität, nur wenn gesperrt und Diebstahl erkannt.
	- COAP_ERROR: Rot - wenn WiFi verbunden aber keine CoAP-Aktivität seit >30s.
	- INIT: Blau-Blink - während Initialisierung oder WiFi-Verbindung.
	- SYSTEM_OK: Grün - normaler Betrieb, alle Systeme funktional.
	- COAP_CONNECTING: Blau (veraltet, nicht mehr aktiv verwendet).

Netzwerkdiagnostik
- WLAN-Scan vor Verbindungsaufbau; klare Statuslogs (z. B. `WL_NO_SSID_AVAIL`).
- Auto-Reconnect: Beim Boot deaktiviert für kontrollierte Verbindungsversuche; nach erfolgreicher Verbindung automatisch aktiviert.
- Manuelle Reconnect-Versuche: alle 60 Sekunden wenn nicht verbunden.
- UDP-Socket wird bei Disconnect sofort gestoppt und bei Reconnect vollständig neu initialisiert.
- CoAP-Server erst nach erfolgreichem WLAN-Connect gestartet.

Build & Deployment
- PlatformIO: Build, Upload, serielle Logs für Diagnose.
- RTC wird beim Flashen auf Build-Zeit gesetzt (aus `__DATE__`/`__TIME__`).

Fehlerbehebung (Troubleshooting)
- WLAN verbindet nicht: SSID im 2,4 GHz-Band, nicht verborgen; Gerät näher am AP; SSID exakt prüfen.
- DHT unzuverlässig: Stabilisierung (200 ms), Lese-Intervall erhöhen, Verkabelung/5V/3,3V und Pullup prüfen.
- Button reagiert nicht: Pull-up/-down-Config beachten, Rohwerte loggen, Verdrahtung kontrollieren.
- UDP-Fehler-Spam: CoAP-Loop nur bei WLAN-Verbindung ausführen.

Roadmap
- Exponentielles Backoff für WiFi-Reconnect (aktuell fest 60s).
- Filterung/Glättung von Bewegungsdaten für stabilere Erkennung.
- Batteriespannungsüberwachung und Warnung bei niedrigem Ladestand.

Hinweise
- APIs: Optional geplante Nutzung externer Wetter-/Zeit-Dienste; aktuell lokal über RTC.
- Zielkriterium: stabiles, energieeffizientes Laufverhalten (>1 h) mit verlässlicher Anzeige/Telemetrie.

Systemarchitektur des ESP32 Fahrrad-Computers
Einleitung und Systemüberblick
Der ESP32 Fahrrad-Computer ist ein autonomes Edge-Computing-System, das speziell für den Einsatz an Fahrrädern entwickelt wurde. Es fungiert als intelligentes IoT-Gerät, das Umgebungsdaten und Bewegungsaktivitäten in Echtzeit erfasst, lokal verarbeitet und über drahtlose Kommunikationstechnologien an einen zentralen Server übermittelt. Das System ist darauf ausgelegt, sowohl als klassischer Fahrradcomputer mit Displayanzeige als auch als Telemetrie-Einheit mit Diebstahlschutzfunktion zu arbeiten.

Hardware-Architektur
Das Herzstück des Systems bildet ein ESP32 DevKit mit einem Dual-Core Xtensa LX6 Prozessor, der mit 240 MHz getaktet ist. Dieser Mikrocontroller übernimmt die zentrale Steuerung aller Peripheriegeräte und die Ausführung der Anwendungslogik. Dank seiner integrierten WiFi-Funktionalität und diversen Low-Power-Modi eignet er sich ideal für batteriebetriebene IoT-Anwendungen.

Die Sensorik des Systems setzt sich aus zwei Hauptkomponenten zusammen. Für die Erfassung von Umweltdaten wird ein DHT22-Sensor verwendet, der Temperatur und relative Luftfeuchtigkeit misst. Zur Bewegungserkennung kommt ein MPU6050 zum Einsatz, ein MEMS-Sensor, der sowohl einen 3-Achsen-Beschleunigungssensor als auch ein 3-Achsen-Gyroskop vereint. Diese Kombination ermöglicht eine präzise Detektion von Fahrzuständen sowie Erschütterungen, die auf einen Diebstahlversuch hindeuten könnten.

Um eine kontinuierliche und präzise Zeitmessung unabhängig von einer Netzwerkverbindung zu gewährleisten, ist das System mit einer DS1302 Echtzeituhr (RTC) ausgestattet. Diese verfügt über eine eigene Batterie-Pufferung und wird beim Flashen der Firmware automatisch mit der Build-Zeit synchronisiert.

Die Interaktion mit dem Benutzer erfolgt über ein 16x2 LCD-Display, das über einen I2C-Bus angesteuert wird. Es visualisiert auf vier umschaltbaren Seiten Informationen wie Uhrzeit, Datum, aktuelle Sensorwerte sowie den Netzwerkstatus. Ergänzt wird die Anzeige durch eine RGB-LED, die den Systemstatus farblich kodiert: Blau signalisiert den Initialisierungs- oder Verbindungsstatus, Grün steht für den regulären Betrieb, und Rot warnt vor Fehlern oder einem aktiven Diebstahlalarm. Ein einfacher Drucktaster ermöglicht dem Nutzer das Durchschalten der verschiedenen Displayseiten.

Software-Architektur und Zustandssteuerung
Die Software basiert auf dem Arduino-Framework und wird mittels PlatformIO entwickelt. Die Anwendungslogik ist als vereinfachte Finite State Machine implementiert, was ein deterministisches und robustes Verhalten gewährleistet. Das System durchläuft dabei vier definierte Zustände:

Nach dem Start befindet sich das System im INIT-Zustand, in dem die Hardware initialisiert, die Sensoren auf Funktionsfähigkeit geprüft werden und der CoAP-Server gestartet wird. Bei erfolgreicher WLAN-Verbindung wechselt es direkt in den IDLE-Zustand.

Im regulären Betrieb unterscheidet das System zwischen zwei Hauptzuständen: IDLE und ACTIVE. Der IDLE-Zustand wird eingenommen, wenn das Fahrrad steht. Hierbei arbeitet das System energiesparend mit reduzierter Sensor-Abtastrate von 1 Hz. Sobald der MPU6050-Sensor eine Bewegung registriert, die definierte Schwellwerte überschreitet, wechselt das System in den ACTIVE-Zustand. In diesem Modus werden die Sensoren mit 5 Hz ausgelesen, um präzise Bewegungsdaten bereitzustellen.

Sollte die Netzwerkverbindung abreißen, geht das System in den DISCONNECTED-Zustand über, in dem es alle 10 Minuten versucht, die Verbindung wiederherzustellen, ohne dabei die lokale Funktionalität (wie die Displayanzeige) zu beeinträchtigen. Der CoAP-Server bleibt verfügbar, sobald die Verbindung wiederhergestellt ist.

Kommunikation und Datenprotokoll
Für die Datenübertragung nutzt das System das CoAP-Protokoll (Constrained Application Protocol) über UDP, was aufgrund seines geringen Overheads ideal für IoT-Anwendungen ist. Das Gerät agiert als CoAP-Server und hostet Ressourcen, die von einer Android-App abgefragt werden können.

Die Nutzdaten werden als kompakte JSON-Objekte formatiert. Unabhängig vom Zustand (IDLE oder ACTIVE) enthält das Datenpaket immer vollständige Informationen: Temperatur, Luftfeuchtigkeit sowie die Rohdaten der Beschleunigungs- und Gyroskopsensoren aller drei Achsen. Ein Statusfeld ("s") kennzeichnet den aktuellen Zustand: "A" für Active (Bewegung) oder "I" für Idle (Ruhe).

Energie-Management
Ein wesentlicher Aspekt der Architektur ist das Energie-Management. Das System nutzt adaptive Verzögerungen in der Hauptschleife (Loop), die je nach Systemzustand variieren: 20ms im ACTIVE-Zustand für schnelle Reaktion, 100ms im IDLE-Zustand für Energieeinsparung, und 1000ms im DISCONNECTED-Zustand zur Minimierung des Verbrauchs während Verbindungsversuchen. Das WiFi-Modul bleibt permanent aktiv (Light-Sleep deaktiviert), um als zuverlässiger CoAP-Server zu fungieren. Deep-Sleep ist bewusst nicht implementiert, da das System kontinuierlich für Abfragen der Android-App verfügbar sein muss.
Zusammenfassend stellt der ESP32 Fahrrad-Computer eine integrierte Lösung dar, die lokale Echtzeitverarbeitung mit effizienter Netzwerk-Konnektivität verbindet und durch ihre modulare Architektur flexibel auf verschiedene Einsatzszenarien angepasst werden kann.

### Detaillierte Beschreibung der CoAP-Schnittstelle

Das Gerät agiert als **CoAP-Server** und hostet Ressourcen, die von einer Android-App abgerufen werden.

*   **Protokoll:** CoAP (Constrained Application Protocol) über UDP.
*   **Port:** `5683` (Standard CoAP-Port)
*   **Architektur:** ESP32 als Server, Android-App als Client

#### Verfügbare Ressourcen:

**1. `/telemetry` (GET)**
*   **Zweck:** Abruf aktueller Sensordaten
*   **Methode:** `GET`
*   **Response:** CoAP ACK mit JSON-Payload
*   **Content-Type:** `application/json`
*   **Polling-Empfehlung:** 1-2 Sekunden für Echtzeit-Updates
*   **Payload-Struktur:**
    ```json
    {
      "t": 24.5,       // Temperatur (Celsius)
      "h": 55.2,       // Luftfeuchtigkeit (%)
      "ax": 0.12,      // Beschleunigung X (m/s²)
      "ay": -0.05,     // Beschleunigung Y (m/s²)
      "az": 0.98,      // Beschleunigung Z (m/s²)
      "gx": 0.01,      // Gyro X (rad/s)
      "gy": 0.02,      // Gyro Y (rad/s)
      "gz": -0.01,     // Gyro Z (rad/s)
      "theft": "N",   // Diebstahlstatus: "Y" = erkannt, "N" = nicht erkannt
      "s": "A"         // Status: "A" für Active, "I" für Idle
    }
    ```

**2. `/cmd` (POST)**
*   **Zweck:** Senden von Befehlen an das Gerät
*   **Methode:** `POST`
*   **Payload:** Text (z.B. "LOCK", "UNLOCK")
*   **Response:** "OK" bei Erfolg
*   **Verwendung:** 
    - **LOCK**: Aktiviert Diebstahlüberwachung (`state.locked = true`). Bei Überschreitung der Theft-Schwellwerte → `theft_detected = true` → LED-SOS-Muster.
    - **UNLOCK**: Deaktiviert Überwachung (`state.locked = false`) und setzt Diebstahlalarm zurück (`theft_detected = false`).

#### Android-Client-Implementierung:
Projektdokumentation: CycleComputer
Version: 1.0 Datum: 11. Dezember 2025
1. Projektübersicht
Das Projekt "CycleComputer" ist eine native Android-Anwendung, die als umfassender Fahrradcomputer dient. Die App verbindet sich über das CoAP-Protokoll mit einem externen IoT-Gerät (z.B. einem ESP32-Mikrocontroller), um Echtzeit-Telemetriedaten zu empfangen und zu visualisieren. Zu den erfassten Daten gehören Temperatur, Luftfeuchtigkeit, Beschleunigungs- und Gyroskopwerte sowie ein Diebstahl- und Gerätestatus. Benutzer können Befehle an das Gerät senden, wie das Ver- oder Entriegeln eines digitalen Schlosses. Die App integriert außerdem Standortdienste, um die aktuelle Geschwindigkeit zu berechnen und detaillierte Wetterdaten für den aktuellen Standort abzurufen.
2. Technische Architektur
Die Anwendung folgt einer Single-Activity-Architektur (DataActivity.java) und nutzt moderne Android-Komponenten und Bibliotheken zur Realisierung ihrer Funktionalitäten.
•
Kommunikationsprotokoll: Die Kernkommunikation mit dem IoT-Gerät erfolgt über CoAP (Constrained Application Protocol), ein leichtgewichtiges Protokoll, das für ressourcenbeschränkte Geräte optimiert ist. Die Implementierung wird durch die californium-core-Bibliothek (org.eclipse.californium:californium-core) realisiert.
•
Datenverarbeitung und -modellierung: Eingehende Daten vom IoT-Gerät werden im JSON-Format erwartet. Die Gson-Bibliothek (com.google.code.gson:gson) wird für das Parsen dieser Daten in stark typisierte Java-Objekte (TelemetryData) verwendet.
•
UI-Aktualisierung und State Management: Die App nutzt Android Architecture Components, insbesondere LiveData und Observer, um eine reaktive und lebenszyklus-bewusste Benutzeroberfläche zu gewährleisten. Der CoapManager (ein Singleton) stellt LiveData-Objekte für Telemetriedaten und den Verbindungsstatus bereit. Die DataActivity beobachtet diese LiveData-Objekte und aktualisiert die UI automatisch bei Änderungen.
•
Standort und Geschwindigkeit:
◦
Der FusedLocationProviderClient (com.google.android.gms:play-services-location) wird genutzt, um den Gerätestandort für die Wetterabfrage zu ermitteln.
◦
Die Geschwindigkeit wird durch die Integration von Beschleunigungssensordaten berechnet. Ein einfacher Hochpassfilter wird angewendet, um die konstante Schwerkraft von der linearen Beschleunigung zu trennen. Durch die Integration dieser linearen Beschleunigung über die Zeit (dt) wird die Geschwindigkeit angenähert.
•
Netzwerkanfragen (Wetter): Für das Abrufen von Wetterdaten von der weatherapi.com-API wird die Fuel-Bibliothek (com.github.kittinunf.fuel:fuel) eingesetzt. Fuel ist ein leichtgewichtiger und fluenter HTTP-Client für Kotlin/Java.
3. Kernkomponenten im Detail
a) DataActivity.java Dies ist die zentrale und einzige Activity der App. Ihre Hauptverantwortlichkeiten sind:
•
UI-Management: Initialisierung und Aktualisierung aller UI-Elemente wie TextViews, Buttons und SwitchCompat.
•
Datenvisualisierung: Anzeige von Temperatur, Luftfeuchtigkeit, Geschwindigkeit, Wetter, Diebstahlwarnung und rohen Sensordaten.
•
Benutzerinteraktionen: Verarbeitung von Klicks auf den "Sende Befehl"-Button (um den Schloss-Status zu senden) und den "Rohdaten"-Button (um die Anzeige der Sensorwerte umzuschalten).
•
Lifecycle-Management: Initialisierung des CoapManager und Registrierung der Observer in onCreate. Die LiveData-Architektur sorgt für eine automatische Bereinigung.
•
Berechtigungsmanagement: Dynamische Anforderung der ACCESS_FINE_LOCATION-Berechtigung zur Laufzeit, die für den Abruf des Standorts und somit der Wetterdaten unerlässlich ist.
b) CoapManager.java (Singleton) Diese Klasse (nicht im Codeausschnitt, aber impliziert) kapselt die gesamte CoAP-Kommunikationslogik.
•
Verbindungsmanagement: Stellt eine "observe"-Beziehung zu einer Ressource auf dem CoAP-Server (dem IoT-Gerät) her, um kontinuierliche Updates zu erhalten.
•
Datenbereitstellung: Empfängt Daten vom Server, verpackt sie in ein MutableLiveData<String> und stellt sie der UI-Schicht zur Verfügung.
•
Status-Management: Verfolgt den Verbindungsstatus (IDLE, ACTIVE, DISCONNECTED) und stellt diesen ebenfalls über ein LiveData<ConnectionState>-Objekt bereit.
•
Befehle senden: Bietet eine Methode (sendCommand), um CoAP-PUT-Anfragen (z.B. "LOCK" / "UNLOCK") an den CoAP-Server zu senden.
c) TelemetryData.java (Datenklasse) Eine einfache POJO (Plain Old Java Object)-Klasse, die die Struktur der vom IoT-Gerät gesendeten JSON-Daten exakt abbildet. Sie wurde um das Feld theft (Diebstahlwarnung) erweitert.
d) WeatherApiResponse.java (Datenklasse) Eine verschachtelte Datenklassenstruktur, die für das Parsen der komplexen JSON-Antwort der Wetter-API mit Gson verwendet wird und detaillierte Wetterinformationen enthält.
App-Dokumentation (Benutzerhandbuch)
1. Einleitung
Willkommen bei der CycleComputer App! Diese App verwandelt Ihr Smartphone in eine Kommandozentrale für Ihr smartes Fahrrad. Sie sehen Live-Daten wie Geschwindigkeit und Temperatur, erhalten Warnungen und können Funktionen wie das digitale Schloss direkt von Ihrem Handy aus steuern.
2. Hauptbildschirm & Statusanzeige
Der Hauptbildschirm zeigt Ihnen alle wichtigen Informationen auf einen Blick. Die Hintergrundfarbe signalisiert den Verbindungsstatus zu Ihrem Fahrrad-Zubehör:
•
Grau: Die App ist bereit, hat aber noch keine aktiven Daten empfangen.
•
Grün: Eine aktive Verbindung besteht, und Daten werden in Echtzeit empfangen.
•
Rot: Die Verbindung zum Gerät wurde unterbrochen. Prüfen Sie, ob das Gerät eingeschaltet und in Reichweite ist.
3. Angezeigte Daten
•
DIEBSTAHL! (Warnung): Ein auffälliger roter Text, der nur dann erscheint, wenn das Gerät eine mögliche Diebstahlaktivität meldet (theft = "Y").
•
Gerätestatus: Zeigt den Betriebsstatus des verbundenen Geräts an (z.B. "ACTIVE" oder "IDLE").
•
Geschwindigkeit: Ihre aktuelle Fahrgeschwindigkeit in Kilometern pro Stunde (km/h), berechnet aus den Sensordaten Ihres Zubehörs.
•
Wetter: Detaillierte Wetterinformationen für Ihren aktuellen Standort, inklusive Beschreibung (z.B. "Sonnig"), Temperatur, gefühlter Temperatur, Luftfeuchtigkeit und Wind. Hierfür ist eine Standortfreigabe erforderlich.
•
Temperatur: Die am Fahrrad gemessene Umgebungstemperatur in Grad Celsius (°C).
•
Luftfeuchtigkeit: Die am Fahrrad gemessene relative Luftfeuchtigkeit in Prozent (%).
4. Steuerelemente
•
Sperren / Entsperren (Schalter):
◦
Mit diesem Schalter wählen Sie den gewünschten Zustand des digitalen Schlosses.
◦
Position "An" (aktiviert): Das Schloss soll verriegelt werden.
◦
Position "Aus" (deaktiviert): Das Schloss soll entriegelt werden.
•
SENDE BEFEHL (Button):
◦
Nachdem Sie den Zustand des Schalters geändert haben, tippen Sie auf diesen Button. Dadurch wird der Befehl ("LOCK" oder "UNLOCK") tatsächlich an Ihr Fahrrad gesendet.
•
ROHDATEN ANZEIGEN/VERBERGEN (Button):
◦
Für technisch interessierte Nutzer. Ein Tipp auf diesen Button blendet die detaillierten Rohdaten der Sensoren ein oder aus:
▪
Beschleunigung (Accel): Die Messwerte der X-, Y- und Z-Achse des Beschleunigungssensors.
▪
Gyroskop (Gyro): Die Drehraten um die X-, Y- und Z-Achse.
5. Erstmalige Einrichtung und Berechtigungen
Beim ersten Start fragt die App nach der Berechtigung für den Standortzugriff. Diese Berechtigung ist notwendig, um die präzisen Wetterdaten für Ihren aktuellen Standort abrufen zu können. Wenn Sie die Berechtigung verweigern, kann das Wetter nicht angezeigt werden und es erscheint "N/A".
6. Fehlerbehandlung
•
"Fehler: Ungültige JSON-Daten": Diese Meldung erscheint, wenn die App Daten vom Gerät in einem unerwarteten Format empfängt. Stellen Sie sicher, dass die Firmware Ihres Zubehörs korrekt arbeitet.
•
Wetter "N/A": Dies kann auftreten, wenn Sie die Standortberechtigung verweigert haben, Ihr Smartphone keinen Standort ermitteln kann oder keine Internetverbindung besteht.